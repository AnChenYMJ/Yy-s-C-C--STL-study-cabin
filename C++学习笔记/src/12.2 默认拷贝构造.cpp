#include <iostream>
using namespace std;

class CST		
{
public:
	int a;
	char c[4];	//默认拷贝构造会逐个复制非静态成员的值
	CST()
	{
		a = 56;			//参数一：空间首地址，参数二：字节大小，参数三：源，即从哪来，如果我们要赋值常量字符串，常量字符串的地址即是源
		strcpy_s(c, 4, "Yys");//字符串结尾以\0结束，常量字符串自带\0占一个字符，
	}						//所以之前的Yy's超了一个字符

	//测试（0）不写拷贝构造函数

	//CST(const CST& d)//测试（1）自写拷贝构造函数，功能与默认相同
	//{
	//	this->a = d.a;
	//	strcpy_s(this->c, 4, d.c);
	//}

	CST(const CST& d)//测试（2）自写拷贝构造函数，功能与默认不相同
	{
		
	}

};

int main()
{
	CST te;
	cout << te.a << " " << te.c << endl;

	//CST ta = te;//测试（0）//不写拷贝构造
	//cout << ta.a << " " << ta.c << endl;//结果是复制了te的值，一定经过了拷贝构造
	////所以证实了，默认拷贝构造是存在的，但它不是默认构造函数，我们管默认的拷贝构造叫浅拷贝

	//CST ta(te);//测试（1）//自写拷贝构造函数，功能与默认相同
	//cout << ta.a << " " << ta.c << endl;//结果是复制了te的值，经过了拷贝构造
	//自己写的构造函数和默认的效果如果一样，也叫浅拷贝

	CST ta(te);//测试（2）//自写拷贝构造函数，功能与默认不相同
	cout << ta.a << " " << ta.c << endl;//发现打印了乱码，因为自写的拷贝构造，把默认的覆盖掉


	//注意：同一类的多个对象，成员地址不同，但空间排布顺序是一样的
	//注意：windows程序员一定要会用MSDN查看函数宏等等


	system("pause");
	return 0;
}