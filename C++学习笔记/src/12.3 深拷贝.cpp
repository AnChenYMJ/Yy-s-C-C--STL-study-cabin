#include <iostream>
using namespace std;

class CT
{
public:
	int* c;
	CT()
	{
		c = new int[3];
		c[0] = 13;
		c[1] = 14;
		c[2] = 15;
	}
	~CT()
	{
		delete[] c;
	}

	//测试（1）使用默认拷贝构造，即不写拷贝构造，使用浅拷贝

	CT(const CT& b)//测试（2）使用深拷贝构造，自写
	{
		//this->c = b.c;//这就是默认拷贝构造的操作，没有重新申请空间，直接使用了之前对象的空间地址
		this->c = new int[3];//想要不与之前的对象的空间重合，就必须重新申请空间，重新申请的空间地址再赋值给c
		//this->c[0] = b.c[0];//挨个复制太麻烦，可用下面的函数
		memcpy(this->c, b.c, 12);//参数一：目标空间，参数二：源空间（参考上节课）参数三：空间总大小
	}
};

CT& fun(CT& a)//函数避免浅拷贝的方法是使用引用和指针
{
	return a;
}

CT* fun(CT* a)//原因是这样就避免了临时对象的构建，避免掉构建新对象使用重复空间的问题，直接引用
{
	return a;
}

CT& fun1(CT* a)//即直接拿构建好的对象来使用，提高效率的同时避免了浅拷贝
{
	return *a;
}

CT* fun1(CT& a)//参数和返回值避免浅拷贝可以引用和指针混合用，但注意返回值的前缀
{
	return &a;
}

int main()
{
	{
		CT te;
		cout << te.c[0] << " " << te.c[1] << " " << te.c[2] << endl;

		//CT ta = te;	//测试（1）	//程序结束崩溃了//报错原因是浅拷贝的缺点
		//cout << ta.c[0] << " " << ta.c[1] << " " << ta.c[2] << endl;
	//}		//浅拷贝当我们在类中声明了一个指针，且new了空间，当调用默认拷贝构造时，把指针装的申请的空间地址
			//也复制给了新的对象，导致两个对象的指针成员指向同一个空间，释放时就出现了重复释放同一空间的问题
			//重复释放同一空间：第一次释放完，空间回归系统，再次释放就算是野指针操作，
			//默认的操作是this->c = b.c

		CT ta = te;	//测试（2）	//成功打印无问题
		cout << ta.c[0] << " " << ta.c[1] << " " << ta.c[2] << endl;
	}//在{}里测试，因为需要测试释放空间

	return 0;
}