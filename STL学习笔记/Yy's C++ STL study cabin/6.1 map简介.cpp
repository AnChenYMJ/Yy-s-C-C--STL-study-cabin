#include <iostream>
#include <map>
using namespace std;

void STLlisten()
{
//顺序容器 和 关联容器
{
	//顺序容器
	//string、vector、list、deque这些都是顺序容器
	//顺序容器，就是像线性一样的，我们插入删除，都像是在一根线上操作。

	//关联容器
	//关联容器的元素由2个值组成：<Ky | 实>	 key-value：键值对
	//Ky 是 键值；实 是 实值。
	//实值 就是数据。
	//键值，就是这个数据的标志，我们通过标志来寻找数据。
	//键值与实值一起组成了关联容器的一个完整元素。
}

//关联容器的分类：有序容器、无序容器
{
//有序容器
	//存储：按照Ky值的大小来排序
	//底层数据结构：红黑树
	//标准：STL的标准库

//无序容器
	//存储：不排序
	//底层数据结构：散列表
	//标准：boost库（准标准模板库，还不是完全的标准库，所以需要我们额外手动添加，不能直接使用）

	//许多好用的容器都不是标准库，需要我们额外手动添加
}

//有序容器介绍
{
//map
	//<Ky | 实> 键值对保存
	//键值不能重复

//multimap
	//<Ky | 实> 键值对保存
	//键值能够重复

//二者除了键值能重复与否，其它都一样
	//map 与 multimap 键值排序举例：
	//map	  :123456789
	//multimap:1223345567789
	//尽管multimap能重复，但是都按照键值顺序来排序的


//set
	//Ky 与 实 是同一个：即 键值 与 实值 是同一个 ，就没有俩个值了，只有一个值，且这个值同时表示键值、实值
	//不允许重复

//multiset
	//允许重复
	//其它与set一样


}

//map介绍
{
//键值保存，高效访问
	//通过键值来排序、查找数据
	//特点：高效访问，比如有1000个数据，list来查找要找1~1000次，而map是1~10次就找到了
	//如果有100万个数据，map 1~20次就找到了，2^n = N  n是查找最多次数，N是总数据量
	//所以说，map在应对数据量很大的情况，且经常查看节点，是非常优秀的，但是假如只有20个数据，那用map就大材小用了，体现不了它的优势
	//插入顺序低于链表，因为涉及到排序的问题

	//底层结构：红黑树（平衡排序二叉树）
	//x=log2^N ：N是数据总量 x是最多查找次数
}

}

int main()
{




	system("pause");
	return 0;
}