#include "queue.h"
#include "huffman.h"
#include <stdio.h>
#include <stdlib.h>


//赫夫曼树介绍
void CCC()
{
	if (1)
	{
		//赫夫曼树是根据赫夫曼编码来实现的，赫夫曼编码是为了使压缩效率更高（电文总长最短），且不影响二义性
		//相关的名词：
		//权：可直接理解为重量，比如实际应用中一个节点被访问的次数相当多，那它的权值就重，或者比如一段字符串，按字母出现次数来讲，某些字幕出现次数高，那它的权值就重
		//节点的路径长度：从根节点到该节点路径上的连接数，就是二叉树画出图来，节点之间的连线，根节点到该节点出现的连线次数
		//树的路径长度：树中每个叶子节点的路径长度之和，
		//节点带权路径长度：节点的路径长度与节点权值的乘积
		//树的带权路径长度：WPL：是树中所有叶子结点的节点带权路径长度之和

		//赫夫曼树就是，权值重的节点靠近上层，即靠近根节点，权值低的就靠近叶子节点
		//目的是使WPL更低，这样效率就高

		//名词：
		//定长编码：像ASCII码，每个字符固定8字节大小，不会变
		//变长编码：单个编码的长度不一致，可以根据整体出现频率来实现
		//前缀码：没有任何码字是其他码字的前缀，例如：有一个字符编码为010，那其它字符的二进制码不可能出现010开头的编码，比如01011这就是不可能出现的，因为不能出现010的前缀
		//赫夫曼编码就属于前缀码

		//赫夫曼树的实现：
		//用一个有顺序的队列来存放节点，从权值最低的两个节点开始取出来，将这两个节点形成一个二叉树，根节点是这两节点的权值之和
		//然后用这个整合过的根节点与队列的队顶元素权值比较（因为两节点取出来，队顶是剩下的元素），大于则放到队顶后面，小于则放到队顶前面，
		//然后再取两个元素进行整合，再插入，不断地重复，直到队列的最后一个元素。这就是赫夫曼树的实现过程，根据赫夫曼编码的特性写的。
	}
}


int main(void)
{
	//传入数据，变成赫夫曼树。（这里可修改成传入文件指针）
	htTree* codeTree = buildTree("I Love FishC.con! Keep Going Y'y!!");

	//将赫夫曼树的数据编码,codeTable用于存放编码
	hlTable* codeTable = buildTable(codeTree);

	//根据输入字符串并打印该字符串的编码
	encode(codeTable, "I Love FishC.con!Keep Going Y'y!");

	//根据输入的编码来输出赫夫曼树的字符
	decode(codeTree, "0101111111111100011100100111100011001010111110101010110110010000");



	system("pause>0");
	return 0;
}