#include <stdio.h>
#include <stdlib.h>

int main(void)
{
	char a = 56;
	char b;
	b = a << 3;

	printf("a = %d \n", a);//56
	printf("b = %d \n\n", b);//结果为-64
			//位左移：a << 3 == a乘以2的n次幂
			//但这里为什么得到-64呢，因为char的范围是-128~127，而56*8 == 448
			//按照计算规则，超出127会重新循环一次，到448就循环到-64
//56：  ---- ----
//	  0011 1000  //56在计算机里的存储方式
//   0011 1000	 //执行位左移，左移三位，左边越界的舍弃不要，右边空缺的补零	
//	  1100 0000	 //左移后的值，在计算机内的存储形式
//			 -1	 //因为最高位符号位是1，为负数，执行反码计算，先-1
//	  1011 1111	 //-1之后
//	  1100 0000	 //数据位取反，100 0000 == 64，加上负号，得到-64



	char c = 98;
	char d;
	d = c >> 2;

	printf("a = %d \n", c);//98
	printf("b = %d \n\n", d);//24
	//位右移：a >> 3 == a除以2的n次幂取整，98/4  == 24------2，取24
	//---- ----
	//0110 0010 //98的计算机存储形式
	//  01 1000 10  //向右移2位，右边越界部分舍弃不要，左边根据操作系统补0或1
	//0001 1000 //这是正数，补0；负数在不同的操作系统里右移补的可能是1或0
	//		//得到0001 1000 == 24 



		//位左移：a << n == a乘以2的n次幂
		//位右移：a >> n == a除以2的n次幂取整，
	//直接乘除的运行效率是非常低的，而利用移位的运算效率非常高
	//所以一些系统级的运算中，常常用到移位运算符
	int e = 255;//因为char的范围小，所以如果我们想要利用位移运算，就用大范围的类型
	int f = 888;
	e <<= 4;  //255* 2*2*2*2 == 4080
	f >>= 5; //888/2*2*2*2*2 == 888/32 == 27-----24 //取整27

	printf("a = %d \n", e);//4080
	printf("b = %d \n\n", f);//27
	

	system("pause");
	return 0;
}