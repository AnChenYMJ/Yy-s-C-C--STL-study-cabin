#include <stdio.h>
#include <stdlib.h>

void fun()
{
	int b = 10;
	static int c = 10;
	b++;
	c++;

	printf("b = %d, %p, c = %d, %p \n\n", b, &b, c, &c);
}

static void fun1()//static加在函数前面，函数就变成静态函数了
{				  //静态函数仅在当前文件下有效，正常的函数是工程下所有文件都能识别
	int a;		  //可看对比参考源文件59.1 test.c，看看再定义一个正常函数fun1会怎样
}

void fun2()   //这是正常函数，看看参考源文件59.1 test.c再定义一个fun2会怎样
{
	int a;
}

int main(void)
{
	{	//static 在局部位置就是静态局部变量，在全局位置就是静态全局变量
		static int a = 45;//静态局部变量的作用域在当前定义位置直到这层代码段的}
		{				
			static int a = 12;//能够嵌套，就是普通的局部变量，唯一的区别就是生命周期的不同
			printf("%d %p \n\n", a, &a);//静态局部变量生命周期与程序共存亡
		}
		printf("%d %p \n\n", a, &a);
	}

	{
		static int a = 65;     //打印这三个静态局部变量做对比会发现，他们的值不一样
		printf("%d %p \n\n", a, &a);//地址也不一样，证明是它们不同的变量
	}


	fun();//b = 11, 0117FA74, c = 11, 00B3A000
	fun();//b = 11, 0117FA74, c = 12, 00B3A000
	fun();//b = 11, 0117FA74, c = 13, 00B3A000
	fun();//b = 11, 0117FA74, c = 14, 00B3A000
	//静态局部变量的值每调用一次函数就变化一次，原理如下：
	//静态变量是在加载资源阶段分配空间，就是在主函数执行之前就分配好了空间
	//主函数执行后调用函数，静态局部变量已经有空间了，不用再分配，直接对空间操作
	//且静态变量的生命周期与程序共存亡，该空间不释放，变化后的值还存在里面
	//参考的局部变量int b在函数调用完就释放空间了，再次调用函数时就再次赋值
	//而静态局部变量就跳过（static int a = 45;），不申请空间（加载时已经申请过了，且声明周期与程序同在）
	//直接在上一次变化的值与空间上直接操作
	//当多次调用函数时就会发现值在一直变化
	//可以截断调试，会发现直接跳过（static int a = 45;）这一步
	//这个例子考试面试经常遇到


	system("pause");
	return 0;
}