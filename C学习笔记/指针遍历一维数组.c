#include <stdio.h>
#include <stdlib.h>

int main(void)
{
	int a[5] = { 8, 5, 6, 2, 3 }; //注意这里的元素值，有人用0 1 2 3 4 参与运算对比，
								//发现在这页的知识点，两种方式的结果数值是一样的，但代表的意义不一样，自己多注意下
	int* p = &a[0]; //指针p指向a[0]即第一个元素的地址
	int i;

	for (i = 0; i < 5; i++)
	{
		//printf("%d  ", *p + i);  //这里的输出结果为 8  9  10  11  12,
								//因为*p 看作是a[0]这个元素的值8，在值上+i就变成了上面结果

		printf("%d  ", *(p + i)); //这样就实现了遍历一维数组，结果为 8 5 6 2 3
								//*（p + i）可看作是a[i]的值，（p+i）看作是a[i]的元素下标
								//利用这种方式最后的p值不会改变，地址加减是一个类型的大小

		//printf("%p  ", *p++);   //这样也实现了遍历一维数组:8 5 6 2 3 , *p++ == *(p++)
								//*p++，是先算p++，再加上*，就实现了a[0]~a[4]的过程、
								//注意最后p的值越界了，变成了a[5]的地址，地址加减是一个类型的大小

		//printf("%p  ", (*p)++);//这里的输出结果为 8  9  10  11  12,
								//*p 看作是a[0]这个元素的值8，然后再对这个值自加
								//注意改变了a[0]的值
	}

	printf("\n");
	//printf("%p, %p, %p, %p, %p \n", p, p + 1, p + 2, p + 3, p + 4);
	printf("%p \n", p);  //查看p的值
	printf("%p, %p, %p, %p, %p \n", &a[0], &a[1], &a[2], &a[3], &a[4]);

	//////printf("%p, %p, %p, %p, %p \n", p++, p++, p++, p++, p++, p++); 这行是错误的，详情见下
	printf("%p \n", p);     //注意：p++还是++p，不能写在同一个语句中出现两次以上，否则会出错
	printf("%p \n", ++p);   //注意：最好不要用p++，因为p++是先用原值参与运算，再自加，导致结果差错
	printf("%p \n", ++p);
	printf("%p \n", ++p);
	printf("%p \n", ++p);
	printf("%p \n", p);     //注意，这种自加方式最后的p值会变，变成a[4]的地址


	system("pause");
	return 0;
}