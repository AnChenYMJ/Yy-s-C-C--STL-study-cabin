#include <stdio.h>
#include <stdlib.h>


int main(void)
{
	int a = 35.86;//降级，发生了自动类型转换，自动把double变成int类型
				//转换就涉及到内存截断，只留整数部分，小数部分不要，所以不会四舍五入
	double b = 32;//升级，这个自动类型转换就合理多了，把4字节放到8字节空间里

	printf("%d, %lf \n", a, b);


	//隐式类型转换：系统自发进行的数据类型转换
	//当多个类型的数据运算时，自动类型转换的优先级从高到低如下：
	//long double 、double、float、unsigned long long、long long、
	//usinged long、unsigned int、long、int

	double c;
	c = 8 + 8 / 0.5f + 7 - 9.0;//由下列原理可得，强制类型转换最后结果会变成最高优先级的数据类型
	//但执行过程是一步一步的改变与运算的，不是一下子变成一种类型再计算。
	printf("%lf \n", c);//结果为22.0000，原理如下：
	//运算优先级高的符号先算，8 / 0.5f， 先把8变成float 8.0f，式子成了8+16.0f+7-9.0
	//然后加减法就从左往右算，把8变成8.0f，成了24.0f+7-9.0,
	//再把7变成7.0f，成了31.0f -9.0，最后把31.0f变成31.0（double类型）
	//最后得到31.0-9.0 == 22.0



	//补充：当出现在表达式中，有无符号的char和short会被自动转成int参与运算。
	//当short与int一样的时候，unsigned short被转成unsigned int
	//在K&R标准（C语言最初的标准，现在是ANSI标准）中, float会被转成double
	//作为函数参数时，char和short会被自动转成int，float会被转成double，可通过函数原型防止提升，函数原型就是函数声明
	//隐式类型转换，就是在上述情况下由系统自发进行的，有些非上述情况也存在自动转换情况，
	//这就是编译器的个人行为，比如malloc 在vs好使，其他编译器不好使。


	//我们在涉及到类型转换的时候，要万分注意.
	//X.maind课件里写的那几种基本数据，就是上述的几种是隐式类型转换，
	//其他的如malloc就不是隐式转换，是编译器提供给我们的方便编程的功能
	int* p = (int*)malloc(8);
	//编译器提供的便利还有就是所有警告与提示都是编译器的功劳不是c语言的标准
	//指针不能这样隐式类型转换

	system("pause");
	return 0;
}