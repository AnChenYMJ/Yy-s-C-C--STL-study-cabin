#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>

int main(void)
{
	int(*p)[5] = (int(*)[5])malloc(sizeof(int) * 5);
	//申请一块空间，(int(*)[5])是声明空间返回的首地址的类型是数组指针，
	//int(*p)[5]是声明一个一维数组指针p来装这个数组地址，[5]是这个数组的元素个数

	int a[5];  //这两行与上面的意思是一样的
	int(*p1)[5] = &a;//一维数组指针的声明

	*(*p + 0) = 2;  //数组名字是数组元素的首地址
	*(*p + 1) = 3;  //*(p+n)== p[n]	
	*(*p + 2) = 4;	//*(指针)就是这个指针指向的变量或空间本身
	*(*p + 3) = 5;	//可看一下遍历一维数组.c的笔记,那里的p是数组元素的首地址	
	*(*p + 4) = 6;	//而这里的p是整个数组的地址，这两个含义不一样，*(p+1)相当于下一个数组了
					//*p == a 而a又代表元素首地址
					//所以这里要用*（*p+n）的形式，如果p是首元素的地址则可以*（p+n）

	int i;

	for (i = 0; i < 5; i++)
	{
		printf("%d  ", (*p)[i]);//不可以用*p[i] *p[0]还代表数组第一个元素，*p[1]开始就代表下一个数组了
	}						  //因为*p[i]是指针数组的表达形式，这里要用(*p)[i]
	printf("\n");			  //此时不能使用下标运算，因为此时p是数组指针，而不是指向单独的元素

	free(p);


	int(*p2)[4][3] = (int(*)[4][3])malloc(sizeof(int) * 12);
	//二维数组指针的声明

	int b[4][3]; //跟上面一样，是二维数组指针的声明
	int(*p3)[4][3] = &b;

	int k,
		j;

	(*p2)[0][0] = 13;
	(*p2)[0][1] = 12;
	(*p2)[0][2] = 11;
	(*p2)[1][0] = 10;
	(*p2)[1][1] = 9;
	*(*(*p2 + 1) + 2) = 8; //注意这两种写法的不同，但含义是一样的
	*(*(*p2 + 2) + 0) = 7; //这种写法是根据*(p + n) == p[n]转化而来的，这公式的p是元素的首地址
	*(*(*p2 + 2) + 1) = 6;//外层是元素的偏移量，内层是一维数组的偏移量
	*(*(*p2 + 2) + 2) = 5;//*p2是二维数组的首元素的地址
	(*p2)[3][0] = 4;
	(*p2)[3][1] = 3;
	(*p2)[3][2] = 2;

	for (k = 0; k < 4; k++)
	{
		for (j = 0; j < 3; j++)
		{
			printf("%d  ", (*p2)[k][j]);
		}
	}

	free(p2);


	system("pause");
	return 0;
}